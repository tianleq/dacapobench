Only in ../build/ycsb-0.17.0/binding-parent/datastore-specific-descriptor: target
Only in ../build/ycsb-0.17.0/binding-parent: target
diff -ur ycsb-0.17.0/cassandra/src/main/java/site/ycsb/db/CassandraCQLClient.java ../build/ycsb-0.17.0/cassandra/src/main/java/site/ycsb/db/CassandraCQLClient.java
--- ycsb-0.17.0/cassandra/src/main/java/site/ycsb/db/CassandraCQLClient.java	2022-06-27 22:44:31.000000000 +1000
+++ ../build/ycsb-0.17.0/cassandra/src/main/java/site/ycsb/db/CassandraCQLClient.java	2022-07-18 15:45:33.999500174 +1000
@@ -587,7 +587,8 @@
 
       return Status.OK;
     } catch (Exception e) {
-      logger.error(MessageFormatter.format("Error inserting key: {}", key).getMessage(), e);
+      System.err.println("Error inserting key: {"+key+"}");
+      System.err.println(e);
     }
 
     return Status.ERROR;
diff -ur ycsb-0.17.0/cassandra/src/test/java/site/ycsb/db/CassandraCQLClientTest.java ../build/ycsb-0.17.0/cassandra/src/test/java/site/ycsb/db/CassandraCQLClientTest.java
--- ycsb-0.17.0/cassandra/src/test/java/site/ycsb/db/CassandraCQLClientTest.java	2022-06-27 22:44:31.000000000 +1000
+++ ../build/ycsb-0.17.0/cassandra/src/test/java/site/ycsb/db/CassandraCQLClientTest.java	2022-07-18 15:45:33.999500174 +1000
@@ -56,7 +56,7 @@
  */
 public class CassandraCQLClientTest {
   // Change the default Cassandra timeout from 10s to 120s for slow CI machines
-  private final static long timeout = 120000L;
+  private final static long timeout = 120000L; // FIXME
 
   private final static String TABLE = "usertable";
   private final static String HOST = "localhost";
Only in ../build/ycsb-0.17.0/cassandra: target
diff -ur ycsb-0.17.0/core/src/main/java/site/ycsb/Client.java ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/Client.java
--- ycsb-0.17.0/core/src/main/java/site/ycsb/Client.java	2022-06-27 22:44:31.000000000 +1000
+++ ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/Client.java	2022-07-18 16:14:18.186814448 +1000
@@ -33,6 +33,9 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
+import java.lang.reflect.Method;
+import java.lang.reflect.InvocationTargetException;
+
 /**
  * Turn seconds remaining into more useful units.
  * i.e. if there are hours or days worth of seconds, use them.
@@ -155,7 +158,6 @@
   private static StatusThread statusthread = null;
 
   // HTrace integration related constants.
-
   /**
    * All keys for configuring the tracing system start with this prefix.
    */
@@ -267,9 +269,10 @@
 
       Measurements.getMeasurements().exportMeasurements(exporter);
     } finally {
-      if (exporter != null) {
-        exporter.close();
-      }
+      // DaCapo XXX: closing the exporter will also close the DaCapo TeePrintStream
+      // if (exporter != null) {
+      //   exporter.close();
+      // }
     }
   }
 
@@ -305,7 +308,6 @@
 
     initWorkload(props, warningthread, workload, tracer);
 
-    System.err.println("Starting test.");
     final CountDownLatch completeLatch = new CountDownLatch(threadcount);
 
     final List<ClientThread> clients = initDb(dbname, props, threadcount, targetperthreadperms,
@@ -337,7 +339,6 @@
       }
 
       st = System.currentTimeMillis();
-
       for (Thread t : threads.keySet()) {
         t.start();
       }
@@ -367,7 +368,6 @@
         if (terminator != null && !terminator.isInterrupted()) {
           terminator.interrupt();
         }
-
         if (status) {
           // wake up status thread if it's asleep
           statusthread.interrupt();
@@ -378,7 +378,7 @@
             // ignored
           }
         }
-
+        System.err.println("\r    100%");
         workload.cleanup();
       }
     } catch (WorkloadException e) {
@@ -396,8 +396,97 @@
       e.printStackTrace();
       System.exit(-1);
     }
+  }
 
-    System.exit(0);
+  private static Method dacapoInitialize;
+  private static Method dacapoStart;
+  private static Method dacapoEnd;
+  private static Method requestStart;
+  private static Method requestFinish;
+  private static Method enableStress;
+  private static Object callback;
+  private static void dacapoInitialize(int transactions, int threads) {
+    try {
+      Class<?> clazz = Class.forName("org.dacapo.harness.LatencyReporter",
+          true, Client.class.getClassLoader());
+      Class<?> callBackClazz = Class.forName("org.dacapo.harness.Callback",
+          true, Client.class.getClassLoader());
+      Class<?> benchmarkClazz = Class.forName("org.dacapo.harness.Benchmark",
+          true, Client.class.getClassLoader());
+      dacapoInitialize = clazz.getMethod("initialize", int.class, int.class);
+      dacapoStart = clazz.getMethod("start", int.class);
+      dacapoEnd = clazz.getMethod("end", int.class);
+      requestStart = callBackClazz.getMethod("requestStart");
+      requestFinish = callBackClazz.getMethod("requestFinish");
+      enableStress = callBackClazz.getMethod("enableStress");
+      callback = benchmarkClazz.getDeclaredField("callback").get(null);
+    } catch (ClassNotFoundException e) {
+      System.err.println("Failed to access DaCapo latency reporter: "+e);
+    } catch (NoSuchMethodException e) {
+      System.err.println("Failed trying to create latency stats: "+e);
+    } catch (NoSuchFieldException e) {
+      System.err.println("Failed to access DaCapo request hook: "+e);
+    } catch (IllegalAccessException e) {
+      System.err.println("Failed to access DaCapo request hook: "+e);
+    }
+
+    try {
+      dacapoInitialize.invoke(null, transactions, threads);  // only one reporter object
+    } catch (IllegalAccessException e) {
+      System.err.println("Failed to access DaCapo latency reporter: "+e);
+    } catch (InvocationTargetException e) {
+      System.err.println("Failed to access DaCapo latency reporter: "+e);
+    }
+  }
+
+  public static void dacapoStart(int threadID) {
+    try {
+      dacapoStart.invoke(null, threadID);  // only one reporter object
+    } catch (IllegalAccessException e) {
+      System.err.println("Failed to access DaCapo latency reporter: "+e);
+    } catch (InvocationTargetException e) {
+      System.err.println("Failed to access DaCapo latency reporter: "+e);
+    }
+  }
+
+  public static void dacapoEnd(int threadID) {
+    try {
+      dacapoEnd.invoke(null, threadID);  // only one reporter object
+    } catch (IllegalAccessException e) {
+      System.err.println("Failed to access DaCapo latency reporter: "+e);
+    } catch (InvocationTargetException e) {
+      System.err.println("Failed to access DaCapo latency reporter: "+e);
+    }
+  }
+
+  public static void requestStart() {
+    try {
+      requestStart.invoke(callback);  // only one reporter object
+    } catch (IllegalAccessException e) {
+      System.err.println("Failed to access DaCapo request start hook: "+e);
+    } catch (InvocationTargetException e) {
+      System.err.println("Failed to access DaCapo request start hook: "+e);
+    }
+  }
+
+  public static void requestFinish() {
+    try {
+      requestFinish.invoke(callback);  // only one reporter object
+    } catch (IllegalAccessException e) {
+      System.err.println("Failed to access DaCapo request finish hook: "+e);
+    } catch (InvocationTargetException e) {
+      System.err.println("Failed to access DaCapo request finish hook: "+e);
+    }
+  }
+
+  public static void enableStress() {
+    try {
+      enableStress.invoke(callback);  // only one reporter object
+    } catch (IllegalAccessException e) {
+      System.err.println("Failed to access MMTK enable stress: "+e);
+    } catch (InvocationTargetException e) {
+      System.err.println("Failed to access MMTK enable stress: "+e);
+    }
   }
 
   private static List<ClientThread> initDb(String dbname, Properties props, int threadcount,
@@ -409,19 +498,26 @@
     final List<ClientThread> clients = new ArrayList<>(threadcount);
     try (final TraceScope span = tracer.newScope(CLIENT_INIT_SPAN)) {
       int opcount;
+
       if (dotransactions) {
         opcount = Integer.parseInt(props.getProperty(OPERATION_COUNT_PROPERTY, "0"));
+        System.err.println("    operations: "+opcount);
+
+        dacapoInitialize(opcount, threadcount);
+
       } else {
         if (props.containsKey(INSERT_COUNT_PROPERTY)) {
           opcount = Integer.parseInt(props.getProperty(INSERT_COUNT_PROPERTY, "0"));
         } else {
           opcount = Integer.parseInt(props.getProperty(RECORD_COUNT_PROPERTY, DEFAULT_RECORD_COUNT));
         }
+        System.err.println("    records: "+props.getProperty(RECORD_COUNT_PROPERTY));
       }
       if (threadcount > opcount){
         threadcount = opcount;
         System.out.println("Warning: the threadcount is bigger than recordcount, the threadcount will be recordcount!");
       }
+
       for (int threadid = 0; threadid < threadcount; threadid++) {
         DB db;
         try {
@@ -506,13 +602,13 @@
     try {
       Properties projectProp = new Properties();
       projectProp.load(classLoader.getResourceAsStream("project.properties"));
-      System.err.println("YCSB Client " + projectProp.getProperty("version"));
+      if (props.getProperty(DO_TRANSACTIONS_PROPERTY).equals(String.valueOf(false))) {
+        System.err.println("    YCSB Client " + projectProp.getProperty("version"));
+        System.err.println("    workload: "+props.getProperty(WORKLOAD_PROPERTY));
+      }
     } catch (IOException e) {
       System.err.println("Unable to retrieve client version.");
     }
-
-    System.err.println();
-    System.err.println("Loading workload...");
     try {
       Class workloadclass = classLoader.loadClass(props.getProperty(WORKLOAD_PROPERTY));
 
@@ -528,15 +624,8 @@
 
   private static Properties parseArguments(String[] args) {
     Properties props = new Properties();
-    System.err.print("Command line:");
-    for (String arg : args) {
-      System.err.print(" " + arg);
-    }
-    System.err.println();
-
     Properties fileprops = new Properties();
     int argindex = 0;
-
     if (args.length == 0) {
       usageMessage();
       System.out.println("At least one argument specifying a workload is required.");
@@ -565,9 +654,11 @@
         props.setProperty(TARGET_PROPERTY, String.valueOf(ttarget));
         argindex++;
       } else if (args[argindex].compareTo("-load") == 0) {
+        System.err.println("Loading database... ");
         props.setProperty(DO_TRANSACTIONS_PROPERTY, String.valueOf(false));
         argindex++;
       } else if (args[argindex].compareTo("-t") == 0) {
+        System.err.println("Running transactions... ");
         props.setProperty(DO_TRANSACTIONS_PROPERTY, String.valueOf(true));
         argindex++;
       } else if (args[argindex].compareTo("-s") == 0) {
diff -ur ycsb-0.17.0/core/src/main/java/site/ycsb/ClientThread.java ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/ClientThread.java
--- ycsb-0.17.0/core/src/main/java/site/ycsb/ClientThread.java	2022-06-27 22:44:31.000000000 +1000
+++ ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/ClientThread.java	2022-08-19 20:47:13.405574609 +1000
@@ -44,6 +44,7 @@
   private Properties props;
   private long targetOpsTickNs;
   private final Measurements measurements;
+  private int fivepercent;
 
   /**
    * Constructor.
@@ -62,6 +63,7 @@
     this.dotransactions = dotransactions;
     this.workload = workload;
     this.opcount = opcount;
+
     opsdone = 0;
     if (targetperthreadperms > 0) {
       targetOpsPerMs = targetperthreadperms;
@@ -103,6 +105,10 @@
       return;
     }
 
+    if (threadid == 0 && opcount*threadcount > 5000) {
+      fivepercent = opcount/20;
+    }
+
     //NOTE: Switching to using nanoTime and parkNanos for time management here such that the measurements
     // and the client thread have the same view on time.
 
@@ -113,18 +119,22 @@
       long randomMinorDelay = ThreadLocalRandom.current().nextInt((int) targetOpsTickNs);
       sleepUntil(System.nanoTime() + randomMinorDelay);
     }
+    // Client.enableStress();
     try {
       if (dotransactions) {
         long startTimeNanos = System.nanoTime();
 
         while (((opcount == 0) || (opsdone < opcount)) && !workload.isStopRequested()) {
 
+          Client.requestStart();
+          Client.dacapoStart(threadid);
           if (!workload.doTransaction(db, workloadstate)) {
             break;
           }
-
+          Client.dacapoEnd(threadid);
+          Client.requestFinish();
           opsdone++;
-
+          progress();
           throttleNanos(startTimeNanos);
         }
       } else {
@@ -135,9 +145,8 @@
           if (!workload.doInsert(db, workloadstate)) {
             break;
           }
-
           opsdone++;
-
+          progress();
           throttleNanos(startTimeNanos);
         }
       }
@@ -158,6 +167,15 @@
     }
   }
 
+  private void progress() {
+    if (fivepercent > 0 && opsdone % fivepercent == 0) {
+      int pct = 5*opsdone/fivepercent;
+      if (pct < 100) {
+        System.err.print("\r    "+pct+"%");
+      }
+    }
+  }
+
   private static void sleepUntil(long deadline) {
     while (System.nanoTime() < deadline) {
       if (!spinSleep) {
diff -ur ycsb-0.17.0/core/src/main/java/site/ycsb/DBWrapper.java ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/DBWrapper.java
--- ycsb-0.17.0/core/src/main/java/site/ycsb/DBWrapper.java	2022-06-27 22:44:31.000000000 +1000
+++ ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/DBWrapper.java	2022-07-18 15:45:33.999500174 +1000
@@ -97,9 +97,11 @@
         }
       }
 
-      System.err.println("DBWrapper: report latency for each error is " +
-          this.reportLatencyForEachError + " and specific error codes to track" +
-          " for latency are: " + this.latencyTrackedErrors.toString());
+      if (reportLatencyForEachError) {
+        System.err.println("DBWrapper: report latency for each error is " +
+            this.reportLatencyForEachError + " and specific error codes to track" +
+            " for latency are: " + this.latencyTrackedErrors.toString());
+      }
     }
   }
 
diff -ur ycsb-0.17.0/core/src/main/java/site/ycsb/workloads/CoreWorkload.java ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/workloads/CoreWorkload.java
--- ycsb-0.17.0/core/src/main/java/site/ycsb/workloads/CoreWorkload.java	2022-06-27 22:44:31.000000000 +1000
+++ ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/workloads/CoreWorkload.java	2022-07-18 15:45:33.999500174 +1000
@@ -617,9 +617,9 @@
 
       } else {
         System.err.println("Error inserting, not retrying any more. number of attempts: " + numOfRetries +
-            "Insertion Retry Limit: " + insertionRetryLimit);
+            "Insertion Retry Limit: " + insertionRetryLimit+ ", Got "+status);
+        Thread.dumpStack();
         break;
-
       }
     } while (true);
 
diff -ur ycsb-0.17.0/core/src/main/java/site/ycsb/workloads/TimeSeriesWorkload.java ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/workloads/TimeSeriesWorkload.java
--- ycsb-0.17.0/core/src/main/java/site/ycsb/workloads/TimeSeriesWorkload.java	2022-06-27 22:44:31.000000000 +1000
+++ ../build/ycsb-0.17.0/core/src/main/java/site/ycsb/workloads/TimeSeriesWorkload.java	2022-07-18 15:45:33.999500174 +1000
@@ -309,11 +309,11 @@
   
   /** Name and default value for the timestamp key property. */
   public static final String TIMESTAMP_KEY_PROPERTY = "timestampkey";
-  public static final String TIMESTAMP_KEY_PROPERTY_DEFAULT = "YCSBTS";
+  public static final String TIMESTAMP_KEY_PROPERTY_DEFAULT = "field4";
   
   /** Name and default value for the value key property. */
   public static final String VALUE_KEY_PROPERTY = "valuekey";
-  public static final String VALUE_KEY_PROPERTY_DEFAULT = "YCSBV";
+  public static final String VALUE_KEY_PROPERTY_DEFAULT = "field5";
   
   /** Name and default value for the timestamp interval property. */    
   public static final String TIMESTAMP_INTERVAL_PROPERTY = "timestampinterval";    
@@ -1014,7 +1014,7 @@
     }
 
     for (int i = 0; i < tagPairs; ++i) {
-      tagKeys[i] = tagKeyGenerator.nextString();
+      tagKeys[i] = "field"+i;
     }
     
     for (int i = 0; i < maxCardinality; i++) {
Only in ../build/ycsb-0.17.0/core: target
Only in ../build/ycsb-0.17.0: target
